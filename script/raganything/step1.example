import sys
import os
import subprocess
import json
import glob
import logging
import datetime
import time

# === 1. è¨­å®šæ—¥èªŒåŠŸèƒ½ (Logging Setup) ===
def setup_logger(log_dir):
    if not os.path.exists(log_dir):
        os.makedirs(log_dir)
    
    # å»ºç«‹ä¸€å€‹å¸¶æœ‰æ™‚é–“æˆ³çš„ log æª”åï¼Œä¾‹å¦‚: run_20231027_153022.log
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    log_file = os.path.join(log_dir, f"run_{timestamp}.log")

    # è¨­å®š Logger
    logger = logging.getLogger("MineruBatch")
    logger.setLevel(logging.INFO)
    logger.handlers = [] # æ¸…ç©ºèˆŠ handler é¿å…é‡è¤‡

    # Handler 1: å¯«å…¥æª”æ¡ˆ (File)
    file_handler = logging.FileHandler(log_file, encoding="utf-8")
    file_formatter = logging.Formatter('%(asctime)s - [%(levelname)s] - %(message)s')
    file_handler.setFormatter(file_formatter)
    logger.addHandler(file_handler)

    # Handler 2: è¼¸å‡ºåˆ°è¢å¹• (Console)
    console_handler = logging.StreamHandler(sys.stdout)
    console_formatter = logging.Formatter('%(message)s') # è¢å¹•é¡¯ç¤ºç°¡æ½”é»ï¼Œä¸ç”¨æ™‚é–“æˆ³
    console_handler.setFormatter(console_formatter)
    logger.addHandler(console_handler)

    logger.info(f"ğŸ“ Log æª”æ¡ˆå·²å»ºç«‹: {log_file}")
    return logger

# === 2. æ ¸å¿ƒè™•ç†é‚è¼¯ ===
def process_single_file(input_path, output_base_dir, step1_std_dir, config, logger):
    filename = os.path.basename(input_path)
    file_stem = os.path.splitext(filename)[0]
    
    logger.info("\n" + "="*60)
    logger.info(f"ğŸš€ [Start] æ­£åœ¨è™•ç†: {filename}")
    logger.info(f"ğŸ“ è·¯å¾‘: {input_path}")
    logger.info("="*60)

    start_time = time.time()

    # çµ„åˆæŒ‡ä»¤
    cmd = [
        "uv", "run", "mineru",
        "-p", input_path,
        "-o", output_base_dir,
        "-m", "auto",
        "-b", config["use_backend"],
        "-d", config["use_device"]
    ]

    logger.info(f"ğŸ”§ åŸ·è¡ŒæŒ‡ä»¤: {' '.join(cmd)}")

    try:
        # ğŸŒŸ é—œéµä¿®æ”¹ï¼šä½¿ç”¨ Popen + PIPE ä¾†å³æ™‚æŠ“å–è¼¸å‡º ğŸŒŸ
        # é€™æ¨£æˆ‘å€‘æ‰èƒ½æŠŠ mineru çš„è¼¸å‡ºåŒæ™‚å¯«å…¥ Log æª”
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT, # æŠŠéŒ¯èª¤ä¹Ÿå°å‘æ¨™æº–è¼¸å‡ºï¼Œçµ±ä¸€è™•ç†
            text=True,
            encoding='utf-8',
            errors='replace' # é˜²æ­¢ç·¨ç¢¼éŒ¯èª¤å°è‡´ crash
        )

        # é€è¡Œè®€å– Mineru çš„è¼¸å‡º
        for line in process.stdout:
            line = line.strip()
            if line:
                # é€™è£¡æœƒåŒæ™‚ print åˆ°è¢å¹• ä¸¦ å¯«å…¥ log æª”
                logger.info(f"   [Mineru] {line}")

        # ç­‰å¾…æŒ‡ä»¤çµæŸ
        return_code = process.wait()

        if return_code != 0:
            logger.error(f"âŒ Mineru åŸ·è¡Œå¤±æ•—ï¼ŒReturn Code: {return_code}")
            return # å¤±æ•—å°±è·³å‡ºï¼Œä¸é€²è¡Œ JSON è™•ç†

        # --- å¾ŒçºŒ JSON è™•ç†é‚è¼¯ (åªæœ‰æˆåŠŸæ‰è·‘) ---
        possible_paths = [
            os.path.join(output_base_dir, file_stem, config["use_backend"], f"{file_stem}_content_list.json"),
            os.path.join(output_base_dir, file_stem, f"{file_stem}_content_list.json"),
        ]
        
        target_json = None
        for p in possible_paths:
            if os.path.exists(p):
                target_json = p
                break
        
        if target_json:
            final_json_name = f"{file_stem}.json"
            final_json_path = os.path.join(step1_std_dir, final_json_name)
            
            try:
                with open(target_json, "r", encoding="utf-8") as f:
                    data = json.load(f)
                
                # æ³¨å…¥åŸå§‹æª”åä¿¡æ¯ (Optional)
                # if isinstance(data, list):
                #     for block in data:
                #         block['original_filename'] = filename

                with open(final_json_path, "w", encoding="utf-8") as f:
                    json.dump(data, f, ensure_ascii=False, indent=2)
                
                duration = time.time() - start_time
                logger.info(f"âœ… è§£ææˆåŠŸï¼è€—æ™‚: {duration:.2f} ç§’")
                logger.info(f"ğŸ’¾ ä¸­é–“æª”å·²å„²å­˜: {final_json_path}")
            
            except Exception as json_err:
                logger.error(f"âš ï¸ JSON è®€å¯«éŒ¯èª¤: {json_err}")
        else:
            logger.error(f"âŒ Mineru é›–ç„¶è·‘å®Œ (Code 0)ï¼Œä½†æ‰¾ä¸åˆ°è¼¸å‡ºçš„ JSON æª”æ¡ˆã€‚")

    except Exception as e:
        logger.error(f"âš ï¸ ç™¼ç”Ÿæœªé æœŸéŒ¯èª¤: {e}", exc_info=True) # exc_info=True æœƒå°å‡ºè©³ç´° traceback

def main():
    # === è¨­å®šå€ ===
    input_dir = "./data/inputs"
    output_dir = "./data/output/step1_vlm_output"
    step1_std_dir = "./step1_output"
    log_dir = "./logs" # å­˜æ”¾ Log æª”æ¡ˆçš„è³‡æ–™å¤¾
    
    config = {
        "use_backend": "vlm-transformers",
        "use_device": "cpu"
    }
    # ============

    # åˆå§‹åŒ– Logger
    logger = setup_logger(log_dir)

    if not os.path.exists(input_dir):
        logger.error(f"âŒ æ‰¾ä¸åˆ°è¼¸å…¥è³‡æ–™å¤¾: {input_dir}")
        return

    if not os.path.exists(step1_std_dir):
        os.makedirs(step1_std_dir)

    files = glob.glob(os.path.join(input_dir, "*.pdf"))
    if not files:
        logger.warning(f"ğŸ“‚ è³‡æ–™å¤¾ {input_dir} å…§æ‰¾ä¸åˆ°ä»»ä½• .pdf æª”æ¡ˆ")
        return

    logger.info(f"ğŸ“¦ ç™¼ç¾ {len(files)} å€‹æª”æ¡ˆï¼Œæº–å‚™é–‹å§‹æ‰¹æ¬¡è™•ç†...")
    logger.info(f"âš™ï¸ è¨­å®š: {json.dumps(config)}")

    success_count = 0
    fail_count = 0

    for i, file_path in enumerate(files):
        logger.info(f"\nâ³ [ç¸½é€²åº¦: {i+1}/{len(files)}]")
        try:
            process_single_file(file_path, output_dir, step1_std_dir, config, logger)
            success_count += 1
        except Exception:
            fail_count += 1
            # é€™è£¡çš„ try-except æ˜¯ç‚ºäº†é˜²æ­¢å–®ä¸€æª”æ¡ˆ crash å°è‡´æ•´å€‹ loop åœæ­¢
            pass 

    logger.info("\n" + "="*60)
    logger.info(f"ğŸ æ‰€æœ‰ä½œæ¥­å®Œæˆï¼")
    logger.info(f"ğŸ“Š çµ±è¨ˆ: ç¸½æ•¸ {len(files)} | æˆåŠŸ (å¤§æ¦‚) {success_count} | å¤±æ•— {fail_count}")
    logger.info(f"ğŸ“ è©³ç´° Log è«‹æŸ¥çœ‹: {log_dir}")

if __name__ == "__main__":
    main()